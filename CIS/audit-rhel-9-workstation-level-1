#!/bin/bash
# Attempt at CIS audit script
echo "> CIS Red Hat Enterprise Linux 9 Benchmark"
echo "> "
echo "> Level 1 - Workstation"
echo "> "
echo "> 1.1.2.1 Ensure /tmp is a separate partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify the output shows that /tmp is mounted. Particular requirements pertaining to mount options are covered in ensuing sections."
findmnt --kernel /tmp
echo "> Ensure that systemd will mount the /tmp partition at boot time."
systemctl is-enabled tmp.mount
echo "> "
echo "> 1.1.2.2 Ensure nodev option set on /tmp partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set for the /tmp mount. Run the following command to verify that the nodev mount option is set. Example:"
findmnt --kernel /tmp | grep nodev
echo "> "
echo "> 1.1.2.3 Ensure noexec option set on /tmp partition (Automated)"
echo "> "
echo "> Verify that the noexec option is set for the /tmp mount. Run the following command to verify that the noexec mount option is set. Example:"
findmnt --kernel /tmp | grep noexec
echo "> "
echo "> 1.1.2.4 Ensure nosuid option set on /tmp partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set for the /tmp mount. Run the following command to verify that the nosuid mount option is set. Example:"
findmnt --kernel /tmp | grep nosuid
echo "> "
echo "> 1.1.3.2 Ensure nodev option set on /var partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set for the /var mount. Run the following command to verify that the nodev mount option is set. Example:"
findmnt --kernel /var | grep nodev
echo "> "
echo "> 1.1.3.3 Ensure nosuid option set on /var partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set for the /var mount. Run the following command to verify that the nosuid mount option is set. Example:"
findmnt --kernel /var | grep nosuid
echo "> "
echo "> 1.1.4.2 Ensure noexec option set on /var/tmp partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the noexec option is set for the /var/tmp mount. Run the following command to verify that the noexec mount option is set. Example:"
findmnt --kernel /var/tmp | grep noexec
echo "> "
echo "> 1.1.4.3 Ensure nosuid option set on /var/tmp partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set for the /var/tmp mount. Run the following command to verify that the nosuid mount option is set. Example:"
findmnt --kernel /var/tmp | grep nosuid
echo "> "
echo "> 1.1.4.4 Ensure nodev option set on /var/tmp partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set for the /var/tmp mount. Run the following command to verify that the nodev mount option is set. Example:"
findmnt --kernel /var/tmp | grep nodev
echo "> "
echo "> 1.1.5.2 Ensure nodev option set on /var/log partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set for the /var/log mount. Run the following command to verify that the nodev mount option is set. Example:"
findmnt --kernel /var/log | grep nodev
echo "> "
echo "> 1.1.5.3 Ensure noexec option set on /var/log partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the noexec option is set for the /var/log mount. Run the following command to verify that the noexec mount option is set. Example:"
findmnt --kernel /var/log | grep noexec
echo "> "
echo "> 1.1.5.4 Ensure nosuid option set on /var/log partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set for the /var/log mount. Run the following command to verify that the nosuid mount option is set. Example:"
findmnt --kernel /var/log | grep nosuid
echo "> "
echo "> 1.1.6.2 Ensure noexec option set on /var/log/audit partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the noexec option is set for the /var/log/audit mount. Run the following command to verify that the noexec mount option is set. Example:"
findmnt --kernel /var/log/audit | grep noexec
echo "> "
echo "> 1.1.6.3 Ensure nodev option set on /var/log/audit partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set for the /var/log/audit mount. Run the following command to verify that the nodev mount option is set. Example:"
findmnt --kernel /var/log/audit | grep nodev
echo "> "
echo "> 1.1.6.4 Ensure nosuid option set on /var/log/audit partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set for the /var/log/audit mount. Run the following command to verify that the nosuid mount option is set. Example:"
findmnt --kernel /var/log/audit | grep nosuid
echo "> "
echo "> 1.1.7.2 Ensure nodev option set on /home partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set for the /home mount. Run the following command to verify that the nodev mount option is set. Example:"
findmnt --kernel /home | grep nodev
echo "> "
echo "> 1.1.7.3 Ensure nosuid option set on /home partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set for the /home mount. Run the following command to verify that the nosuid mount option is set. Example:"
findmnt --kernel /home | grep nosuid
echo "> "
echo "> 1.1.8.1 Ensure /dev/shm is a separate partition (Automated)"
echo "> "
echo "> Audit:"
echo "> IF /dev/shm is to be used on the system, run the following command and verify the output shows that /dev/shm is mounted. Particular requirements pertaining to mount options are covered in ensuing sections."
findmnt --kernel /dev/shm
echo "> "
echo "> 1.1.8.2 Ensure nodev option set on /dev/shm partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nodev option is set if a /dev/shm partition exists. Run the following command and verify that nothing is returned:"
mount | grep -E '\s/dev/shm\s' | grep -v nodev
echo "> "
echo "> 1.1.8.3 Ensure noexec option set on /dev/shm partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the noexec option is set for the /dev/shm mount. Run the following command to verify that the noexec mount option is set. Example:"
findmnt --kernel /dev/shm | grep noexec
echo "> "
echo "> 1.1.8.4 Ensure nosuid option set on /dev/shm partition (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that the nosuid option is set if a /dev/shm partition exists. Run the following command and verify that nothing is returned:"
mount | grep -E '\s/dev/shm\s' | grep -v nosuid
echo "> "
echo "> 1.2.1 Ensure GPG keys are configured (Manual)"
echo "> "
echo "> Audit:"
echo "> List all GPG key URLs"
echo "> Each repository should have a gpgkey with a URL pointing to the location of the GPG key, either local or remote."
grep -r gpgkey /etc/yum.repos.d/* /etc/dnf/dnf.conf
echo "> "
echo "> 1.2.2 Ensure gpgcheck is globally activated (Automated)"
echo "> "
echo "> Audit:"
echo "> Global configuration. Run the following command and verify that gpgcheck is set to 1:"
grep ^gpgcheck /etc/dnf/dnf.conf
echo "> "
echo "> 1.2.3 Ensure package manager repositories are configured (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify repositories are configured correctly. The output may vary depending on which repositories are currently configured on the system. Example:"
dnf repolist
echo "> "
echo "> 1.3.1 Ensure AIDE is installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify aide is installed:"
rpm -q aide
echo "> "
echo "> 1.3.2 Ensure filesystem integrity is regularly checked (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands to verify a cron job scheduled to run the aide check."
grep -Ers '^([^#]+\s+)?(\/usr\/s?bin\/|^\s*)aide(\.wrapper)?\s(--?\S+\s)*(--(check|update)|\$AIDEARGS)\b' /etc/cron.* /etc/crontab /var/spool/cron/
echo "> "
echo "> 1.3.3 Ensure cryptographic mechanisms are used to protect the integrity of audit tools (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that Advanced Intrusion Detection Environment (AIDE) is properly configured . Run the following command to verify that AIDE is configured to use cryptographic mechanisms to protect the integrity of audit tools:"
grep -Ps -- '(\/sbin\/(audit|au)\H*\b)' /etc/aide.conf.d/*.conf /etc/aide.conf
echo "> "
echo "> 1.4.1 Ensure bootloader password is set (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify the bootloader password has been set:"
awk -F. '/^\s*GRUB2_PASSWORD/ {print $1"."$2"."$3}' /boot/grub2/user.cfg
echo "> "
echo "> 1.4.2 Ensure permissions on bootloader config are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands to verify correct permissions, ownership, and group for the grub files: Run the following command to verify correct permissions, ownership, and group for grub.cfg"
stat -Lc "%n %#a %u/%U %g/%G" /boot/grub2/grub.cfg
echo "> "
echo "> 1.5.1 Ensure core dump storage is disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify Storage is set to none in /etc/systemd/coredump.conf:"
grep -i '^\s*storage\s*=\s*none' /etc/systemd/coredump.conf
echo "> "
echo "> 1.5.2 Ensure core dump backtraces are disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify ProcessSizeMax is set to 0 in /etc/systemd/coredump.conf:"
grep -Pi '^\h*ProcessSizeMax\h*=\h*0\b' /etc/systemd/coredump.conf || echo -e "\n- Audit results:\n ** Fail **\n - \"ProcessSizeMax\" is: \"$(grep -i 'ProcessSizeMax' /etc/systemd/coredump.conf)\""
echo "> "
echo "> 1.5.3 Ensure address space layout randomization (ASLR) is enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following script to verify kernel.randomize_va_space is set to 2:"
/usr/bin/env bash { l_output="" l_output2="" l_parlist="kernel.randomize_va_space=2" l_searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf $([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)" KPC() { l_krp="$(sysctl "$l_kpname" | awk -F= '{print $2}' | xargs)" l_pafile="$(grep -Psl -- "^\h*$l_kpname\h*=\h*$l_kpvalue\b\h*(#.*)?$" $l_searchloc)" l_fafile="$(grep -s -- "^\s*$l_kpname" $l_searchloc | grep -Pv -- "\h*=\h*$l_kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$l_krp" = "$l_kpvalue" ]; then l_output="$l_output\n - \"$l_kpname\" is set to \"$l_kpvalue\" in the running configuration" else l_output2="$l_output2\n - \"$l_kpname\" is set to \"$l_krp\" in the running configuration" fi if [ -n "$l_pafile" ]; then l_output="$l_output\n - \"$l_kpname\" is set to \"$l_kpvalue\" in \"$l_pafile\"" else l_output2="$l_output2\n - \"$l_kpname = $l_kpvalue\" is not set in a kernel parameter configuration file" fi [ -n "$l_fafile" ] && l_output2="$l_output2\n - \"$l_kpname\" is set incorrectly in \"$l_fafile\"" } for l_kpe in $l_parlist; do l_kpname="$(awk -F= '{print $1}' <<< "$l_kpe")" l_kpvalue="$(awk -F= '{print $2}' <<< "$l_kpe")" KPC done if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }
echo "> "
echo "> 1.6.1.1 Ensure SELinux is installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify SELinux is installed. Run the following command:"
rpm -q libselinux
echo "> "
echo "> 1.6.1.2 Ensure SELinux is not disabled in bootloader configuration (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that neither the selinux=0 or enforcing=0 parameters have been set:"
grubby --info=ALL | grep -Po '(selinux|enforcing)=0\b'
echo "> "
echo "> 1.6.1.3 Ensure SELinux policy is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands and ensure output matches either " targeted " or " mls ":"
grep -E '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config
sestatus | grep Loaded
echo "> "
echo "> 1.6.1.4 Ensure the SELinux mode is not disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands and ensure output matches: Run the following command to verify SELinux's current mode:"
getenforce
echo "> "
echo "> 1.6.1.6 Ensure no unconfined services exist (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify not output is produced:"
ps -eZ | grep unconfined_service_t
echo "> "
echo "> 1.6.1.8 Ensure the MCS Translation Service (mcstrans) is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify mcstrans is not installed. Run the following command:"
rpm -q mcstrans
echo "> "
echo "> 1.7.1 Ensure message of the day is configured properly (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that the contents match site policy:"
cat /etc/motd
echo "> Run the following command and verify no results are returned:"
grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/motd
echo "> "
echo "> 1.7.2 Ensure local login warning banner is configured properly (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that the contents match site policy:"
cat /etc/issue
echo "> Run the following command and verify no results are returned:"
grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue
echo "> "
echo "> 1.7.3 Ensure remote login warning banner is configured properly (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that the contents match site policy:"
cat /etc/issue.net
echo "> Run the following command and verify no results are returned:"
grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue.net
echo "> "
echo "> 1.7.4 Ensure permissions on /etc/motd are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access is 644 :"
stat -L /etc/motd
echo "> "
echo "> 1.7.5 Ensure permissions on /etc/issue are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access is 644 :"
stat -L /etc/issue
echo "> "
echo "> 1.7.6 Ensure permissions on /etc/issue.net are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access is 644 :"
stat -L /etc/issue.net
echo "> "
echo "> 1.8.2 Ensure GDM login banner is configured (Automated)"
echo "> "
echo "> Run the following script to verify that the text banner on the login screen is enabled and set:"
/usr/bin/env bash { l_pkgoutput="" if command -v dpkg-query > /dev/null 2>&1; then l_pq="dpkg-query -W" elif command -v rpm > /dev/null 2>&1; then l_pq="rpm -q" fi l_pcl="gdm gdm3" # Space seporated list of packages to check for l_pn in $l_pcl; do $l_pq "$l_pn" > /dev/null 2>&1 && l_pkgoutput="$l_pkgoutput\n - Package: \"$l_pn\" exists on the system\n - checking configuration" done if [ -n "$l_pkgoutput" ]; then l_output="" l_output2="" echo -e "$l_pkgoutput" # Look for existing settings and set variables if they exist l_gdmfile="$(grep -Prils '^\h*banner-message-enable\b' /etc/dconf/db/*.d)" if [ -n "$l_gdmfile" ]; then # Set profile name based on dconf db directory ({PROFILE_NAME}.d) l_gdmprofile="$(awk -F\/ '{split($(NF-1),a,".");print a[1]}' <<< "$l_gdmfile")" # Check if banner message is enabled if grep -Pisq '^\h*banner-message-enable=true\b' "$l_gdmfile"; then l_output="$l_output\n - The \"banner-message-enable\" option is enabled in \"$l_gdmfile\"" else l_output2="$l_output2\n - The \"banner-message-enable\" option is not enabled" fi l_lsbt="$(grep -Pios '^\h*banner-message-text=.*$' "$l_gdmfile")" if [ -n "$l_lsbt" ]; then l_output="$l_output\n - The \"banner-message-text\" option is set in \"$l_gdmfile\"\n - banner-message-text is set to:\n - \"$l_lsbt\"" else l_output2="$l_output2\n - The \"banner-message-text\" option is not set" fi if grep -Pq "^\h*system-db:$l_gdmprofile" /etc/dconf/profile/"$l_gdmprofile"; then l_output="$l_output\n - The \"$l_gdmprofile\" profile exists" else l_output2="$l_output2\n - The \"$l_gdmprofile\" profile doesn't exist" fi if [ -f "/etc/dconf/db/$l_gdmprofile" ]; then l_output="$l_output\n - The \"$l_gdmprofile\" profile exists in the dconf database" else l_output2="$l_output2\n - The \"$l_gdmprofile\" profile doesn't exist in the dconf database" fi else l_output2="$l_output2\n - The \"banner-message-enable\" option isn't configured" fi else echo -e "\n\n - GNOME Desktop Manager isn't installed\n - Recommendation is Not Applicable\n- Audit result:\n *** PASS ***\n" fi # Report results. If no failures output in l_output2, we pass if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }
echo "> "
echo "> 1.8.3 Ensure GDM disable-user-list option is enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following script and to verify that the disable-user-list option is enabled or GNOME isn't installed:"
/usr/bin/env bash { l_pkgoutput="" if command -v dpkg-query > /dev/null 2>&1; then l_pq="dpkg-query -W" elif command -v rpm > /dev/null 2>&1; then l_pq="rpm -q" fi l_pcl="gdm gdm3" # Space seporated list of packages to check for l_pn in $l_pcl; do $l_pq "$l_pn" > /dev/null 2>&1 && l_pkgoutput="$l_pkgoutput\n - Package: \"$l_pn\" exists on the system\n - checking configuration" done if [ -n "$l_pkgoutput" ]; then output="" output2="" l_gdmfile="$(grep -Pril '^\h*disable-user-list\h*=\h*true\b' /etc/dconf/db)" if [ -n "$l_gdmfile" ]; then output="$output\n - The \"disable-user-list\" option is enabled in \"$l_gdmfile\"" l_gdmprofile="$(awk -F\/ '{split($(NF-1),a,".");print a[1]}' <<< "$l_gdmfile")" if grep -Pq "^\h*system-db:$l_gdmprofile" /etc/dconf/profile/"$l_gdmprofile"; then output="$output\n - The \"$l_gdmprofile\" exists" else output2="$output2\n - The \"$l_gdmprofile\" doesn't exist" fi if [ -f "/etc/dconf/db/$l_gdmprofile" ]; then output="$output\n - The \"$l_gdmprofile\" profile exists in the dconf database" else output2="$output2\n - The \"$l_gdmprofile\" profile doesn't exist in the dconf database" fi else output2="$output2\n - The \"disable-user-list\" option is not enabled" fi if [ -z "$output2" ]; then echo -e "$l_pkgoutput\n- Audit result:\n *** PASS: ***\n$output\n" else echo -e "$l_pkgoutput\n- Audit Result:\n *** FAIL: ***\n$output2\n" [ -n "$output" ] && echo -e "$output\n" fi else echo -e "\n\n - GNOME Desktop Manager isn't installed\n - Recommendation is Not Applicable\n- Audit result:\n *** PASS ***\n" fi }
echo "> "
echo "> 1.8.4 Ensure GDM screen locks when the user is idle (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following script to verify that the screen locks when the user is idle:"
echo "> "
/usr/bin/env bash { # Check if GNMOE Desktop Manager is installed. If package isn't installed, recommendation is Not Applicable\n # determine system's package manager l_pkgoutput="" if command -v dpkg-query > /dev/null 2>&1; then l_pq="dpkg-query -W" elif command -v rpm > /dev/null 2>&1; then l_pq="rpm -q" fi # Check if GDM is installed l_pcl="gdm gdm3" # Space seporated list of packages to check for l_pn in $l_pcl; do $l_pq "$l_pn" > /dev/null 2>&1 && l_pkgoutput="$l_pkgoutput\n - Package: \"$l_pn\" exists on the system\n - checking configuration" done # Check configuration (If applicable) if [ -n "$l_pkgoutput" ]; then l_output="" l_output2="" l_idmv="900" # Set for max value for idle-delay in seconds l_ldmv="5" # Set for max value for lock-delay in seconds # Look for idle-delay to determine profile in use, needed for remaining tests l_kfile="$(grep -Psril '^\h*idle-delay\h*=\h*uint32\h+\d+\b' /etc/dconf/db/*/)" # Determine file containing idle-delay key if [ -n "$l_kfile" ]; then # set profile name (This is the name of a dconf database) l_profile="$(awk -F'/' '{split($(NF-1),a,".");print a[1]}' <<< "$l_kfile")" #Set the key profile name l_pdbdir="/etc/dconf/db/$l_profile.d" # Set the key file dconf db directory # Confirm that idle-delay exists, includes unit32, and value is between 1 and max value for idle-delay l_idv="$(awk -F 'uint32' '/idle-delay/{print $2}' "$l_kfile" | xargs)" if [ -n "$l_idv" ]; then [ "$l_idv" -gt "0" -a "$l_idv" -le "$l_idmv" ] && l_output="$l_output\n - The \"idle-delay\" option is set to \"$l_idv\" seconds in \"$l_kfile\"" [ "$l_idv" = "0" ] && l_output2="$l_output2\n - The \"idle-delay\" option is set to \"$l_idv\" (disabled) in \"$l_kfile\"" [ "$l_idv" -gt "$l_idmv" ] && l_output2="$l_output2\n - The \"idle-delay\" option is set to \"$l_idv\" seconds (greater than $l_idmv) in \"$l_kfile\"" else l_output2="$l_output2\n - The \"idle-delay\" option is not set in \"$l_kfile\"" fi # Confirm that lock-delay exists, includes unit32, and value is between 0 and max value for lock-delay l_ldv="$(awk -F 'uint32' '/lock-delay/{print $2}' "$l_kfile" | xargs)" if [ -n "$l_ldv" ]; then [ "$l_ldv" -ge "0" -a "$l_ldv" -le "$l_ldmv" ] && l_output="$l_output\n - The \"lock-delay\" option is set to \"$l_ldv\"
echo "> "
echo "> seconds in \"$l_kfile\"" [ "$l_ldv" -gt "$l_ldmv" ] && l_output2="$l_output2\n - The \"lock-delay\" option is set to \"$l_ldv\" seconds (greater than $l_ldmv) in \"$l_kfile\"" else l_output2="$l_output2\n - The \"lock-delay\" option is not set in \"$l_kfile\"" fi # Confirm that dconf profile exists if grep -Psq "^\h*system-db:$l_profile" /etc/dconf/profile/*; then l_output="$l_output\n - The \"$l_profile\" profile exists" else l_output2="$l_output2\n - The \"$l_profile\" doesn't exist" fi # Confirm that dconf profile database file exists if [ -f "/etc/dconf/db/$l_profile" ]; then l_output="$l_output\n - The \"$l_profile\" profile exists in the dconf database" else l_output2="$l_output2\n - The \"$l_profile\" profile doesn't exist in the dconf database" fi else l_output2="$l_output2\n - The \"idle-delay\" option doesn't exist, remaining tests skipped" fi else l_output="$l_output\n - GNOME Desktop Manager package is not installed on the system\n - Recommendation is not applicable" fi # Report results. If no failures output in l_output2, we pass [ -n "$l_pkgoutput" ] && echo -e "\n$l_pkgoutput" if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }"
echo "> "
echo "> Note:"
echo "> • idle-delay=uint32 Should be 900 seconds (15 minutes) or less, not 0 (disabled) and follow local site policy"
echo "> • lock-delay=uint32 should be 5 seconds or less and follow local site policy"
echo "> "
echo "> 1.8.5 Ensure GDM screen locks cannot be overridden (Automated)"
echo "> "
/usr/bin/env bash { # Check if GNOME Desktop Manager is installed. If package isn't installed, recommendation is Not Applicable\n # determine system's package manager l_pkgoutput="" if command -v dpkg-query > /dev/null 2>&1; then l_pq="dpkg-query -W" elif command -v rpm > /dev/null 2>&1; then l_pq="rpm -q" fi # Check if GDM is installed l_pcl="gdm gdm3" # Space seporated list of packages to check for l_pn in $l_pcl; do $l_pq "$l_pn" > /dev/null 2>&1 && l_pkgoutput="$l_pkgoutput\n - Package: \"$l_pn\" exists on the system\n - checking configuration" done # Check configuration (If applicable) if [ -n "$l_pkgoutput" ]; then l_output="" l_output2="" # Look for idle-delay to determine profile in use, needed for remaining tests l_kfd="/etc/dconf/db/$(grep -Psril '^\h*idle-delay\h*=\h*uint32\h+\d+\b' /etc/dconf/db/*/ | awk -F'/' '{split($(NF-1),a,".");print a[1]}').d" #set directory of key file to be locked l_kfd2="/etc/dconf/db/$(grep -Psril '^\h*lock-delay\h*=\h*uint32\h+\d+\b' /etc/dconf/db/*/ | awk -F'/' '{split($(NF-1),a,".");print a[1]}').d" #set directory of key file to be locked if [ -d "$l_kfd" ]; then # If key file directory doesn't exist, options can't be locked if grep -Prilq '\/org\/gnome\/desktop\/session\/idle-delay\b' "$l_kfd"; then l_output="$l_output\n - \"idle-delay\" is locked in \"$(grep -Pril '\/org\/gnome\/desktop\/session\/idle-delay\b' "$l_kfd")\"" else l_output2="$l_output2\n - \"idle-delay\" is not locked" fi else l_output2="$l_output2\n - \"idle-delay\" is not set so it can not be locked" fi if [ -d "$l_kfd2" ]; then # If key file directory doesn't exist, options can't be locked if grep -Prilq '\/org\/gnome\/desktop\/screensaver\/lock-delay\b' "$l_kfd2"; then l_output="$l_output\n - \"lock-delay\" is locked in \"$(grep -Pril '\/org\/gnome\/desktop\/screensaver\/lock-delay\b' "$l_kfd2")\"" else l_output2="$l_output2\n - \"lock-delay\" is not locked" fi else l_output2="$l_output2\n - \"lock-delay\" is not set so it can not be locked" fi else l_output="$l_output\n - GNOME Desktop Manager package is not installed on the system\n - Recommendation is not applicable" fi # Report results. If no failures output in l_output2, we pass [ -n "$l_pkgoutput" ] && echo -e "\n$l_pkgoutput" if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }
echo "> "
echo "> 1.8.8 Ensure GDM autorun-never is enabled (Automated)"
echo "> "
/usr/bin/env bash { l_pkgoutput="" l_output="" l_output2="" # Check if GNOME Desktop Manager is installed. If package isn't installed, recommendation is Not Applicable\n # determine system's package manager if command -v dpkg-query > /dev/null 2>&1; then l_pq="dpkg-query -W" elif command -v rpm > /dev/null 2>&1; then l_pq="rpm -q" fi # Check if GDM is installed l_pcl="gdm gdm3" # Space separated list of packages to check for l_pn in $l_pcl; do $l_pq "$l_pn" > /dev/null 2>&1 && l_pkgoutput="$l_pkgoutput\n - Package: \"$l_pn\" exists on the system\n - checking configuration" echo -e "$l_pkgoutput" done # Check configuration (If applicable) if [ -n "$l_pkgoutput" ]; then echo -e "$l_pkgoutput" # Look for existing settings and set variables if they exist l_kfile="$(grep -Prils -- '^\h*autorun-never\b' /etc/dconf/db/*.d)" # Set profile name based on dconf db directory ({PROFILE_NAME}.d) if [ -f "$l_kfile" ]; then l_gpname="$(awk -F\/ '{split($(NF-1),a,".");print a[1]}' <<< "$l_kfile")" fi # If the profile name exist, continue checks if [ -n "$l_gpname" ]; then l_gpdir="/etc/dconf/db/$l_gpname.d" # Check if profile file exists if grep -Pq -- "^\h*system-db:$l_gpname\b" /etc/dconf/profile/*; then l_output="$l_output\n - dconf database profile file \"$(grep -Pl -- "^\h*system-db:$l_gpname\b" /etc/dconf/profile/*)\" exists" else l_output2="$l_output2\n - dconf database profile isn't set" fi # Check if the dconf database file exists if [ -f "/etc/dconf/db/$l_gpname" ]; then l_output="$l_output\n - The dconf database \"$l_gpname\" exists" else l_output2="$l_output2\n - The dconf database \"$l_gpname\" doesn't exist" fi # check if the dconf database directory exists if [ -d "$l_gpdir" ]; then l_output="$l_output\n - The dconf directory \"$l_gpdir\" exitst" else l_output2="$l_output2\n - The dconf directory \"$l_gpdir\" doesn't exist" fi # check autorun-never setting if grep -Pqrs -- '^\h*autorun-never\h*=\h*true\b' "$l_kfile"; then l_output="$l_output\n - \"autorun-never\" is set to true in:
echo "> "
echo "> \"$l_kfile\"" else l_output2="$l_output2\n - \"autorun-never\" is not set correctly" fi else # Settings don't exist. Nothing further to check l_output2="$l_output2\n - \"autorun-never\" is not set" fi else l_output="$l_output\n - GNOME Desktop Manager package is not installed on the system\n - Recommendation is not applicable" fi # Report results. If no failures output in l_output2, we pass if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }"
echo "> "
echo "> 1.8.9 Ensure GDM autorun-never is not overridden (Automated)"
echo "> "
/usr/bin/env bash { # Check if GNOME Desktop Manager is installed. If package isn't installed, recommendation is Not Applicable\n # determine system's package manager l_pkgoutput="" if command -v dpkg-query > /dev/null 2>&1; then l_pq="dpkg-query -W" elif command -v rpm > /dev/null 2>&1; then l_pq="rpm -q" fi # Check if GDM is installed l_pcl="gdm gdm3" # Space separated list of packages to check for l_pn in $l_pcl; do $l_pq "$l_pn" > /dev/null 2>&1 && l_pkgoutput="$l_pkgoutput\n - Package: \"$l_pn\" exists on the system\n - checking configuration" done # Check configuration (If applicable) if [ -n "$l_pkgoutput" ]; then l_output="" l_output2="" # Look for idle-delay to determine profile in use, needed for remaining tests l_kfd="/etc/dconf/db/$(grep -Psril '^\h*autorun-never\b' /etc/dconf/db/*/ | awk -F'/' '{split($(NF-1),a,".");print a[1]}').d" #set directory of key file to be locked if [ -d "$l_kfd" ]; then # If key file directory doesn't exist, options can't be locked if grep -Piq '^\h*\/org/gnome\/desktop\/media-handling\/autorun-never\b' "$l_kfd"; then l_output="$l_output\n - \"autorun-never\" is locked in \"$(grep -Pil '^\h*\/org/gnome\/desktop\/media-handling\/autorun-never\b' "$l_kfd")\"" else l_output2="$l_output2\n - \"autorun-never\" is not locked" fi else l_output2="$l_output2\n - \"autorun-never\" is not set so it can not be locked" fi else l_output="$l_output\n - GNOME Desktop Manager package is not installed on the system\n - Recommendation is not applicable" fi # Report results. If no failures output in l_output2, we pass [ -n "$l_pkgoutput" ] && echo -e "\n$l_pkgoutput" if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }
echo "> "
echo "> 1.8.10 Ensure XDCMP is not enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify the output:"
grep -Eis '^\s*Enable\s*=\s*true' /etc/gdm/custom.conf
echo "> "
echo "> 1.10 Ensure system-wide crypto policy is not legacy (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that the system-wide crypto policy is not LEGACY"
grep -E -i '^\s*LEGACY\s*(\s+#.*)?$' /etc/crypto-policies/config
echo "> "
echo "> 2.1.1 Ensure time synchronization is in use (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands to verify that chrony is installed:"
rpm -q chrony
echo "> "
echo "> 2.1.2 Ensure chrony is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify remote server is configured properly:"
grep -E "^(server|pool)" /etc/chrony.conf
echo "> Run the following command and verify OPTIONS includes '-u chrony':"
grep ^OPTIONS /etc/sysconfig/chronyd
echo "> "
echo "> 2.2.4 Ensure DHCP Server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify dhcp-server is not installed:"
rpm -q dhcp-server
echo "> "
echo "> 2.2.5 Ensure DNS Server is not installed (Automated)"
echo "> Audit:"
echo "> Run one of the following commands to verify bind is not installed:"
rpm -q bind
echo "> "
echo "> 2.2.6 Ensure VSFTP Server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify vsftpd is not installed:"
rpm -q vsftpd
echo "> "
echo "> 2.2.7 Ensure TFTP Server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify tftp-server is not installed:"
rpm -q tftp-server
echo "> "
echo "> 2.2.8 Ensure a web server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify httpd and nginx are not installed:"
rpm -q httpd nginx
echo "> "
echo "> 2.2.9 Ensure IMAP and POP3 server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify dovecot and cyrus-imapd are not installed:"
rpm -q dovecot cyrus-imapd
echo "> "
echo "> 2.2.10 Ensure Samba is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify samba is not installed:"
rpm -q samba
echo "> "
echo "> 2.2.11 Ensure HTTP Proxy Server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify squid is not installed:"
rpm -q squid
echo "> "
echo "> 2.2.12 Ensure net-snmp is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify net-snmp is not installed:"
rpm -q net-snmp
echo "> "
echo "> 2.2.13 Ensure telnet-server is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify the telnet-server package is not installed:"
echo "> rpm -q telnet-server"
echo "> "
echo "> 2.2.14 Ensure dnsmasq is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run one of the following commands to verify dnsmasq is not installed:"
rpm -q dnsmasq
echo "> "
echo "> 2.2.15 Ensure mail transfer agent is configured for local-only mode (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that the MTA is not listening on any non-loopback address ( 127.0.0.1 or ::1 ) Nothing should be returned"
ss -lntu | grep -E ':25\s' | grep -E -v '\s(127.0.0.1|\[?::1\]?):25\s'
echo "> "
echo "> 2.2.16 Ensure nfs-utils is not installed or the nfs-server service is masked (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify nfs-utils is not installed:"
rpm -q nfs-utils package nfs-utils is not installed
echo "> OR If the nfs-utils package is required as a dependency, run the following command to verify that the nfs-server service is masked:"
systemctl is-enabled nfs-server
echo "> "
echo "> 2.2.17 Ensure rpcbind is not installed or the rpcbind services are masked (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify rpcbind is not installed:"
rpm -q rpcbind package rpcbind is not installed
echo "> OR If the rpcbind package is required as a dependency, run the following commands to verify that the rpcbind and rpcbind.socket systemd units are masked:"
systemctl is-enabled rpcbind
systemctl is-enabled rpcbind.socket
echo "> "
echo "> 2.2.18 Ensure rsync-daemon is not installed or the rsyncd service is masked (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that rsync is not installed:"
rpm -q rsync-daemon package rsync is not installed
echo "> OR Run the following command to verify the rsyncd service is masked:"
systemctl is-enabled rsyncd
echo "> "
echo "> 2.3.1 Ensure telnet client is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that the telnet package is not installed:"
rpm -q telnet
echo "> "
echo "> 2.3.2 Ensure LDAP client is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that the openldap-clients package is not installed:"
rpm -q openldap-clients
echo "> "
echo "> 2.3.3 Ensure TFTP client is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify tftp is not installed:"
rpm -q tftp
echo "> "
echo "> 2.3.4 Ensure FTP client is not installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify ftp is not installed:"
rpm -q ftp
echo "> "
echo "> 2.4 Ensure nonessential services listening on the system are removed or masked (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following command:"
ss -plntu
echo "> "
echo "> 3.1.1 Ensure IPv6 status is identified (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following to identify if IPv6 is enabled on the system:"
grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable && echo -e "\n - IPv6 is enabled\n" || echo -e "\n - IPv6 is not enabled\n"
echo "> "
echo "> 3.2.1 Ensure IP forwarding is disabled (Automated)"
echo "> "
/usr/bin/env bash { l_output="" l_output2="" l_kparameters="net.ipv4.ip_forward=0 net.ipv6.conf.all.forwarding=0" # Space separated list searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf $([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)" kernel_par_chk() { krp="" pafile="" fafile="" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" [ "$krp" = "$kpvalue" ] && l_output="$l_output\n - \"$kpname\" is set to \"$kpvalue\" in the running configuration" [ -n "$pafile" ] && l_output="$l_output\n - \"$kpname\" is set to \"$kpvalue\" in \"$pafile\"" [ -z "$fafile" ] && l_output="$l_output\n - \"$kpname\" is not set incorectly in a kernel parameter configuration file" [ "$krp" != "$kpvalue" ] && l_output2="$l_output2\n - \"$kpname\" is incorrectly set to \"$krp\" in the running configuration" [ -n "$fafile" ] && l_output2="$l_output2\n - \"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && l_output2="$l_output2\n - \"$kpname = $kpvalue\" is not set in a kernel parameter configuration file" } for l_kpar in $l_kparameters; do kpname="$(awk -F"=" '{print $1}' <<< "$l_kpar" | xargs)" kpvalue="$(awk -F"=" '{print $2}' <<< "$l_kpar" | xargs)" if grep -Pq '^\h*net\.ipv6\.' <<< "$l_kpname"; then if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then kernel_par_chk else l_output="$l_output\n - IPv6 is not enabled, check for: \"$l_kpar\" is not applicable" fi else kernel_par_chk fi done if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n ** PASS **\n$l_output\n" else echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n" [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n" fi }
echo "> "
echo "> 3.2.2 Ensure packet redirect sending is disabled (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.conf.all.send_redirects" kpvalue="0" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.1 Ensure source routed packets are not accepted (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.conf.all.accept_source_route" kpvalue="0" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.2 Ensure ICMP redirects are not accepted (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.conf.all.accept_redirects" kpvalue="0" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.3 Ensure secure ICMP redirects are not accepted (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.conf.all.secure_redirects" kpvalue="0" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.4 Ensure suspicious packets are logged (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.conf.all.log_martians" kpvalue="1" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.5 Ensure broadcast ICMP requests are ignored (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.icmp_echo_ignore_broadcasts" kpvalue="1" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.6 Ensure bogus ICMP responses are ignored (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.icmp_ignore_bogus_error_responses" kpvalue="1" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.7 Ensure Reverse Path Filtering is enabled (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.conf.all.rp_filter" kpvalue="1" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.8 Ensure TCP SYN Cookies is enabled (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv4.tcp_syncookies" kpvalue="1" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.3.9 Ensure IPv6 router advertisements are not accepted (Automated)"
echo "> "
/usr/bin/env bash { krp="" pafile="" fafile="" kpname="net.ipv6.conf.all.accept_ra" kpvalue="0" searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf" krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)" pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)" fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')" if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then echo -e "\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"" else echo -e "\nFAIL: " [ "$krp" != "$kpvalue" ] && echo -e "\"$kpname\" is set to \"$krp\" in the running configuration\n" [ -n "$fafile" ] && echo -e "\n\"$kpname\" is set incorrectly in \"$fafile\"" [ -z "$pafile" ] && echo -e "\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n" fi }
echo "> "
echo "> 3.4.1.1 Ensure nftables is installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that nftables is installed:"
rpm -q nftables
echo "> "
echo "> 3.4.1.2 Ensure a single firewall configuration utility is in use (Automated)"
echo "> "
/usr/bin/env bash { l_output="" l_output2="" l_fwd_status="" l_nft_status="" l_fwutil_status="" # Determine FirewallD utility Status rpm -q firewalld > /dev/null 2>&1 && l_fwd_status="$(systemctl is-enabled firewalld.service):$(systemctl is-active firewalld.service)" # Determine NFTables utility Status rpm -q nftables > /dev/null 2>&1 && l_nft_status="$(systemctl is-enabled nftables.service):$(systemctl is-active nftables.service)" l_fwutil_status="$l_fwd_status:$l_nft_status" case $l_fwutil_status in enabled:active:masked:inactive|enabled:active:disabled:inactive) l_output="\n - FirewallD utility is in use, enabled and active\n - NFTables utility is correctly disabled or masked and inactive" ;; masked:inactive:enabled:active|disabled:inactive:enabled:active) l_output="\n - NFTables utility is in use, enabled and active\n - FirewallD utility is correctly disabled or masked and inactive" ;; enabled:active:enabled:active) l_output2="\n - Both FirewallD and NFTables utilities are enabled and active" ;; enabled:*:enabled:*) l_output2="\n - Both FirewallD and NFTables utilities are enabled" ;; *:active:*:active) l_output2="\n - Both FirewallD and NFTables utilities are enabled" ;; :enabled:active) l_output="\n - NFTables utility is in use, enabled, and active\n - FirewallD package is not installed" ;; :) l_output2="\n - Neither FirewallD or NFTables is installed." ;; *:*:) l_output2="\n - NFTables package is not installed on the system" ;; *) l_output2="\n - Unable to determine firewall state" ;; esac if [ -z "$l_output2" ]; then echo -e "\n- Audit Results:\n ** Pass **\n$l_output\n" else echo -e "\n- Audit Results:\n ** Fail **\n$l_output2\n" fi }
echo "> "
echo "> 3.4.2.1 Ensure firewalld default zone is set (Automated)"
echo "> "
/usr/bin/env bash { l_output="" l_output2="" l_zone="" if systemctl is-enabled firewalld.service | grep -q 'enabled'; then l_zone="$(firewall-cmd --get-default-zone)" if [ -n "$l_zone" ]; then l_output=" - The default zone is set to: \"$l_zone\"" else l_output2=" - The default zone is not set" fi else l_output=" - FirewallD is not in use on the system" fi if [ -z "$l_output2" ]; then echo -e "\n- Audit Results:\n ** Pass **\n$l_output\n" else echo -e "\n- Audit Results:\n ** Fail **\n$l_output2\n" fi }
echo "> "
echo "> 3.4.2.2 Ensure at least one nftables table exists (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that a nftables table exists:"
nft list tables
echo "> Return should include a list of nftables. At least one table should be returned"
echo "> "
echo "> 3.4.2.3 Ensure nftables base chains exist (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands and verify that base chains exist for INPUT, FORWARD, and OUTPUT."
nft list ruleset | grep 'hook input'
nft list ruleset | grep 'hook forward'
nft list ruleset | grep 'hook output'
echo "> "
echo "> 3.4.2.3 Ensure nftables base chains exist (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands and verify that base chains exist for INPUT, FORWARD, and OUTPUT."
nft list ruleset | grep 'hook input'
nft list ruleset | grep 'hook forward'
nft list ruleset | grep 'hook output'
echo "> "
echo "> 3.4.2.4 Ensure host based firewall loopback traffic is configured (Automated)"
echo "> "
/usr/bin/env bash { l_output="" l_output2="" if nft list ruleset | awk '/hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -Pq -- '\H+\h+"lo"\h+accept'; then l_output="$l_output\n - Network traffic to the loopback address is correctly set to accept" else l_output2="$l_output2\n - Network traffic to the loopback address is not set to accept" fi l_ipsaddr="$(nft list ruleset | awk '/filter_IN_public_deny|hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -P -- 'ip\h+saddr')" if grep -Pq -- 'ip\h+saddr\h+127\.0\.0\.0\/8\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' <<< "$l_ipsaddr" || grep -Pq -- 'ip\h+daddr\h+\!\=\h+127\.0\.0\.1\h+ip\h+saddr\h+127\.0\.0\.1\h+drop' <<< "$l_ipsaddr"; then l_output="$l_output\n - IPv4 network traffic from loopback address correctly set to drop" else l_output2="$l_output2\n - IPv4 network traffic from loopback address not set to drop" fi if grep -Pq -- '^\h*0\h*$' /sys/module/ipv6/parameters/disable; then l_ip6saddr="$(nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep 'ip6 saddr')" if grep -Pq 'ip6\h+saddr\h+::1\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' <<< "$l_ip6saddr" || grep -Pq -- 'ip6\h+daddr\h+\!=\h+::1\h+ip6\h+saddr\h+::1\h+drop' <<< "$l_ip6saddr"; then l_output="$l_output\n - IPv6 network traffic from loopback address correctly set to drop" else l_output2="$l_output2\n - IPv6 network traffic from loopback address not set to drop" fi fi if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n *** PASS ***\n$l_output" else echo -e "\n- Audit Result:\n *** FAIL ***\n$l_output2\n\n - Correctly set:\n$l_output" fi }
echo "> "
echo "> 3.4.2.5 Ensure firewalld drops unnecessary services and ports (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following command and review output to ensure that listed services and ports follow site policy."
systemctl is-enabled firewalld.service | grep -q 'enabled' && firewall-cmd --list-all --zone="$(firewall-cmd --list-all | awk '/\(active\)/ { print $1 }')" | grep -P -- '^\h*(services:|ports:)'
echo "> "
echo "> 3.4.2.6 Ensure nftables established connections are configured (Manual)"
echo "> "
echo "> Audit:"
echo "> If NFTables utility is in use on your system: Run the following commands and verify all rules for established incoming connections match site policy:"
systemctl is-enabled nftables.service | grep -q 'enabled' && nft list ruleset | awk '/hook input/,/}/' | grep 'ct state'
echo "> "
echo "> 3.4.2.7 Ensure nftables default deny firewall policy (Automated)"
echo "> "
echo "> Audit:"
echo "> If NFTables utility is in use on your system: Run the following commands and verify that base chains contain a policy of DROP."
systemctl --quiet is-enabled nftables.service && nft list ruleset | grep 'hook input' | grep -v 'policy drop'
echo "> Nothing should be returned"
echo "> "
systemctl --quiet is-enabled nftables.service && nft list ruleset | grep 'hook forward' | grep -v 'policy drop'
echo "> Nothing should be returned"
echo "> "
echo "> 3.4.2.7 Ensure nftables default deny firewall policy (Automated)"
echo "> "
echo "> Audit:"
echo "> If NFTables utility is in use on your system: Run the following commands and verify that base chains contain a policy of DROP."
systemctl --quiet is-enabled nftables.service && nft list ruleset | grep 'hook input' | grep -v 'policy drop'
echo "> Nothing should be returned"
systemctl --quiet is-enabled nftables.service && nft list ruleset | grep 'hook forward' | grep -v 'policy drop'
echo "> Nothing should be returned"
echo "> "
echo "> 4.2.1.1 Ensure rsyslog is installed (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify rsyslog is installed. Run the following command:"
rpm -q rsyslog
echo "> "
echo "> 4.2.1.2 Ensure rsyslog service is enabled (Automated)"
echo "> Audit:"
echo "> Run the following command to verify rsyslog is enabled:"
systemctl is-enabled rsyslog
echo "> "
echo "> 4.2.1.3 Ensure journald is configured to send logs to rsyslog (Manual)"
echo "> "
echo "> Audit:"
echo "> IF RSyslog is the preferred method for capturing logs Review /etc/systemd/journald.conf and verify that logs are forwarded to rsyslog."
grep ^\s*ForwardToSyslog /etc/systemd/journald.conf
echo "> Verify the output matches:"
echo "> ForwardToSyslog=yes"
echo "> "
echo "> 4.2.1.4 Ensure rsyslog default file permissions are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command:"
grep -Ps '^\h*\$FileCreateMode\h+0[0,2,4,6][0,2,4]0\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
echo "> Verify the output is includes 0640 or more restrictive:"
echo "> FileCreateMode 0640"
echo "> "
echo "> 4.2.1.5 Ensure logging is configured (Manual)"
echo "> "
echo "> Audit:"
echo "> Review the contents of /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files to ensure appropriate logging is set. In addition, run the following command and verify that the log files are logging information as expected:"
ls -l /var/log/
echo "> "
echo "> 4.2.1.6 Ensure rsyslog is configured to send logs to a remote log host (Manual)"
echo "> "
echo "> Audit:"
echo "> Review the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files and verify that logs are sent to a central host (where loghost.example.com is the name of your central log host):"
echo "> Old format"
grep "^*.*[^I][^I]*@" /etc/rsyslog.conf /etc/rsyslog.d/*.conf
echo "> Output should include @@<FQDN or IP of remote loghost>, for example"
echo "> *.* @@loghost.example.com"
echo "> New format"
grep -E '^\s*([^#]+\s+)?action\(([^#]+\s+)?\btarget=\"?[^#"]+\"?\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
echo "> Output should include target=<FQDN or IP of remote loghost>, for example:"
echo "> *.* action(type="omfwd" target="loghost.example.com" port="514" protocol="tcp""
echo "> "
echo "> 4.2.1.7 Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
echo "> "
echo "> Audit:"
echo "> Review the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files and verify that the system is not configured to accept incoming logs. New format"
grep -Ps -- '^\h*module\(load="imtcp"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
grep -Ps -- '^\h*input\(type="imtcp" port="514"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
echo "> No output expected. -OR- Old format"
grep -s '$ModLoad imtcp' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
grep -s '$InputTCPServerRun' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
echo "> No output expected."
echo "> "
echo "> 4.2.2.1.4 Ensure journald is not configured to receive logs from a remote client (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify systemd-journal-remote.socket is not enabled:"
systemctl is-enabled systemd-journal-remote.socket
echo "> Verify the output matches:"
echo "> masked"
echo "> "
echo "> 4.2.2.2 Ensure journald service is enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify systemd-journald is enabled:"
systemctl is-enabled systemd-journald.service
echo "> Verify the output matches:"
echo "> static"
echo "> "
echo "> 4.2.2.3 Ensure journald is configured to compress large log files (Automated)"
echo "> "
echo "> Audit:"
echo "> Review /etc/systemd/journald.conf and verify that large files will be compressed:"
grep ^\s*Compress /etc/systemd/journald.conf
echo "> Verify the output matches:"
echo "> Compress=yes"
echo "> "
echo "> 4.2.2.4 Ensure journald is configured to write logfiles to persistent disk (Automated)"
echo "> "
echo "> Audit:"
echo "> Review /etc/systemd/journald.conf and verify that logs are persisted to disk:"
grep ^\s*Storage /etc/systemd/journald.conf
echo "> Verify the output matches:"
echo "> Storage=persistent"
echo "> "
echo "> 4.2.2.5 Ensure journald is not configured to send logs to rsyslog (Manual)"
echo "> "
echo "> Audit:"
echo "> IF journald is the method for capturing logs Review /etc/systemd/journald.conf and verify that logs are not forwarded to rsyslog."
grep ^\s*ForwardToSyslog /etc/systemd/journald.conf
echo "> Verify that there is no output."
echo "> "
echo "> 4.2.2.6 Ensure journald log rotation is configured per site policy (Manual)"
echo "> "
echo "> Audit:"
echo "> Review /etc/systemd/journald.conf and verify logs are rotated according to site policy. The specific parameters for log rotation are:"
echo "> SystemMaxUse="
echo "> SystemKeepFree="
echo "> RuntimeMaxUse="
echo "> RuntimeKeepFree="
echo "> MaxFileSec="
echo "> "
echo "> 4.2.2.7 Ensure journald default file permissions configured (Manual)"
echo "> "
echo "> Audit:"
echo "> First see if there is an override file /etc/tmpfiles.d/systemd.conf. If so, this file will override all default settings as defined in /usr/lib/tmpfiles.d/systemd.conf and should be inspected."
echo "> If there is no override file, inspect the default /usr/lib/tmpfiles.d/systemd.conf against the site specific requirements."
echo "> Ensure that file permissions are 0640."
echo "> Should a site policy dictate less restrictive permissions, ensure to follow said policy."
echo "> NOTE: More restrictive permissions such as 0600 is implicitly sufficient."
echo "> "
echo "> 4.2.3 Ensure all logfiles have appropriate permissions and ownership (Automated)"
echo "> "
/usr/bin/env bash { echo -e "\n- Start check - logfiles have appropriate permissions and ownership" output="" UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs) find /var/log -type f | (while read -r fname; do bname="$(basename "$fname")" fugname="$(stat -Lc "%U %G" "$fname")" funame="$(awk '{print $1}' <<< "$fugname")" fugroup="$(awk '{print $2}' <<< "$fugname")" fuid="$(stat -Lc "%u" "$fname")" fmode="$(stat -Lc "%a" "$fname")" case "$bname" in lastlog | lastlog.* | wtmp | wtmp.* | wtmp-* | btmp | btmp.* | btmp-*) if ! grep -Pq -- '^\h*[0,2,4,6][0,2,4,6][0,4]\h*$' <<< "$fmode"; then output="$output\n- File: \"$fname\" mode: \"$fmode\"\n" fi if ! grep -Pq -- '^\h*root\h+(utmp|root)\h*$' <<< "$fugname"; then output="$output\n- File: \"$fname\" ownership: \"$fugname\"\n" fi ;; secure | auth.log | syslog | messages) if ! grep -Pq -- '^\h*[0,2,4,6][0,4]0\h*$' <<< "$fmode"; then output="$output\n- File: \"$fname\" mode: \"$fmode\"\n" fi if ! grep -Pq -- '^\h*(syslog|root)\h+(adm|root)\h*$' <<< "$fugname"; then output="$output\n- File: \"$fname\" ownership: \"$fugname\"\n" fi ;; SSSD | sssd) if ! grep -Pq -- '^\h*[0,2,4,6][0,2,4,6]0\h*$' <<< "$fmode"; then output="$output\n- File: \"$fname\" mode: \"$fmode\"\n" fi if ! grep -Piq -- '^\h*(SSSD|root)\h+(SSSD|root)\h*$' <<< "$fugname"; then output="$output\n- File: \"$fname\" ownership: \"$fugname\"\n" fi ;; gdm | gdm3) if ! grep -Pq -- '^\h*[0,2,4,6][0,2,4,6]0\h*$' <<< "$fmode"; then output="$output\n- File: \"$fname\" mode: \"$fmode\"\n" fi if ! grep -Pq -- '^\h*(root)\h+(gdm3?|root)\h*$' <<< "$fugname"; then output="$output\n- File: \"$fname\" ownership: \"$fugname\"\n" fi ;; *.journal | *.journal~) if ! grep -Pq -- '^\h*[0,2,4,6][0,4]0\h*$' <<< "$fmode"; then output="$output\n- File: \"$fname\" mode: \"$fmode\"\n" fi
echo "> Page 521"
echo "> if ! grep -Pq -- '^\h*(root)\h+(systemd-journal|root)\h*$' <<< "$fugname"; then output="$output\n- File: \"$fname\" ownership: \"$fugname\"\n" fi ;; *) if ! grep -Pq -- '^\h*[0,2,4,6][0,4]0\h*$' <<< "$fmode"; then output="$output\n- File: \"$fname\" mode: \"$fmode\"\n" fi if [ "$fuid" -ge "$UID_MIN" ] || ! grep -Pq -- '(adm|root|'"$(id -gn "$funame")"')' <<< "$fugroup"; then if [ -n "$(awk -v grp="$fugroup" -F: '$1==grp {print $4}' /etc/group)" ] || ! grep -Pq '(syslog|root)' <<< "$funame"; then output="$output\n- File: \"$fname\" ownership: \"$fugname\"\n" fi fi ;; esac done # If all files passed, then we pass if [ -z "$output" ]; then echo -e "\n- Audit Results:\n ** Pass **\n- All files in \"/var/log/\" have appropriate permissions and ownership\n" else # print the reason why we are failing echo -e "\n- Audit Results:\n ** Fail **\n$output" fi echo -e "- End check - logfiles have appropriate permissions and ownership\n" ) }"
echo "> "
echo "> 4.3 Ensure logrotate is configured (Manual)"
echo "> "
echo "> Audit:"
echo "> Review /etc/logrotate.conf and /etc/logrotate.d/* and verify logs are rotated according to site policy."
echo "> "
echo "> 5.1.1 Ensure cron daemon is enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify cron is enabled:"
systemctl is-enabled crond
echo "> "
echo "> 5.1.2 Ensure permissions on /etc/crontab are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other :"
stat /etc/crontab
echo "> Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)"
echo "> "
echo "> 5.1.3 Ensure permissions on /etc/cron.hourly are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other :"
stat /etc/cron.hourly
echo "> Access: (0700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)"
echo "> "
echo "> 5.1.4 Ensure permissions on /etc/cron.daily are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other :"
stat /etc/cron.daily
echo "> Access: (0700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)"
echo "> "
echo "> 5.1.5 Ensure permissions on /etc/cron.weekly are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other :"
stat /etc/cron.weekly
echo "> Access: (0700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)"
echo "> "
echo "> 5.1.6 Ensure permissions on /etc/cron.monthly are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other :"
stat /etc/cron.monthly
echo "> Access: (0700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)"
echo "> "
echo "> 5.1.7 Ensure permissions on /etc/cron.d are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other :"
stat /etc/cron.d
echo "> Access: (0700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)"
echo "> "
echo "> 5.1.8 Ensure cron is restricted to authorized users (Automated)"
echo "> "
/usr/bin/env bash { if rpm -q cronie >/dev/null; then [ -e /etc/cron.deny ] && echo "Fail: cron.deny exists" if [ ! -e /etc/cron.allow ]; then echo "Fail: cron.allow doesn't exist" else ! stat -Lc "%a" /etc/cron.allow | grep -Eq "[0,2,4,6]00" && echo "Fail: cron.allow mode too permissive" ! stat -Lc "%u:%g" /etc/cron.allow | grep -Eq "^0:0$" && echo "Fail: cron.allow owner and/or group not root" fi if [ ! -e /etc/cron.deny ] && [ -e /etc/cron.allow ] && stat -Lc "%a" /etc/cron.allow | grep -Eq "[0,2,4,6]00" \ && stat -Lc "%u:%g" /etc/cron.allow | grep -Eq "^0:0$"; then echo "Pass" fi else echo "Pass: cron is not installed on the system" fi }
echo "> "
echo "> 5.1.9 Ensure at is restricted to authorized users (Automated)"
echo "> "
/usr/bin/env bash { if rpm -q at >/dev/null; then [ -e /etc/at.deny ] && echo "Fail: at.deny exists" if [ ! -e /etc/at.allow ]; then echo "Fail: at.allow doesn't exist" else ! stat -Lc "%a" /etc/at.allow | grep -Eq "[0,2,4,6]00" && echo "Fail: at.allow mode too permissive" ! stat -Lc "%u:%g" /etc/at.allow | grep -Eq "^0:0$" && echo "Fail: at.allow owner and/or group not root" fi if [ ! -e /etc/at.deny ] && [ -e /etc/at.allow ] && stat -Lc "%a" /etc/at.allow | grep -Eq "[0,2,4,6]00" \ && stat -Lc "%u:%g" /etc/at.allow | grep -Eq "^0:0$"; then echo "Pass" fi else echo "Pass: at is not installed on the system" fi }
echo "> "
echo "> 5.2.1 Ensure permissions on /etc/ssh/sshd_config are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify Uid and Gid are both 0/root and Access does not grant permissions to group or other:"
stat -Lc "%n %a %u/%U %g/%G"
echo "> /etc/ssh/sshd_config /etc/ssh/sshd_config 600 0/root 0/root"
echo "> "
echo "> 5.2.2 Ensure permissions on SSH private host key files are configured (Automated)"
echo "> "
/usr/bin/env bash { l_output="" l_output2="" l_skgn="ssh_keys" # Group designated to own openSSH keys l_skgid="$(awk -F: '($1 == "'"$l_skgn"'"){print $3}' /etc/group)" [ -n "$l_skgid" ] && l_cga="$l_skgn" || l_cga="root" awk '{print}' <<< "$(find -L /etc/ssh -xdev -type f -exec stat -Lc "%n %#a %U %G %g" {} +)" | (while read -r l_file l_mode l_owner l_group l_gid; do if file "$l_file" | grep -Pq ':\h+OpenSSH\h+private\h+key\b'; then [ "$l_gid" = "$l_skgid" ] && l_pmask="0137" || l_pmask="0177" l_maxperm="$( printf '%o' $(( 0777 & ~$l_pmask )) )" if [ $(( $l_mode & $l_pmask )) -gt 0 ]; then l_output2="$l_output2\n - File: \"$l_file\" is mode \"$l_mode\" should be mode: \"$l_maxperm\" or more restrictive" else l_output="$l_output\n - File: \"$l_file\" is mode \"$l_mode\" should be mode: \"$l_maxperm\" or more restrictive" fi if [ "$l_owner" != "root" ]; then l_output2="$l_output2\n - File: \"$l_file\" is owned by: \"$l_owner\" should be owned by \"root\"" else l_output="$l_output\n - File: \"$l_file\" is owned by: \"$l_owner\" should be owned by \"root\"" fi if [ "$l_group" != "root" ] && [ "$l_gid" != "$l_skgid" ]; then l_output2="$l_output2\n - File: \"$l_file\" is owned by group \"$l_group\" should belong to group \"$l_cga\"" else l_output="$l_output\n - File: \"$l_file\" is owned by group \"$l_group\" should belong to group \"$l_cga\"" fi fi done if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n *** PASS ***\n$l_output" else echo -e "\n- Audit Result:\n *** FAIL ***\n$l_output2\n\n - Correctly set:\n$l_output" fi ) }
echo "> "
echo "> 5.2.3 Ensure permissions on SSH public host key files are configured (Automated)"
echo "> "
/usr/bin/env bash { l_output="" l_output2="" l_pmask="0133" awk '{print}' <<< "$(find -L /etc/ssh -xdev -type f -exec stat -Lc "%n %#a %U %G" {} +)" | (while read -r l_file l_mode l_owner l_group; do if file "$l_file" | grep -Pq ':\h+OpenSSH\h+(\H+\h+)?public\h+key\b'; then l_maxperm="$( printf '%o' $(( 0777 & ~$l_pmask )) )" if [ $(( $l_mode & $l_pmask )) -gt 0 ]; then l_output2="$l_output2\n - Public key file: \"$l_file\" is mode \"$l_mode\" should be mode: \"$l_maxperm\" or more restrictive" else l_output="$l_output\n - Public key file: \"$l_file\" is mode \"$l_mode\" should be mode: \"$l_maxperm\" or more restrictive" fi if [ "$l_owner" != "root" ]; then l_output2="$l_output2\n - Public key file: \"$l_file\" is owned by: \"$l_owner\" should be owned by \"root\"" else l_output="$l_output\n - Public key file: \"$l_file\" is owned by: \"$l_owner\" should be owned by \"root\"" fi if [ "$l_group" != "root" ]; then l_output2="$l_output2\n - Public key file: \"$l_file\" is owned by group \"$l_group\" should belong to group \"root\"\n" else l_output="$l_output\n - Public key file: \"$l_file\" is owned by group \"$l_group\" should belong to group \"root\"\n" fi fi done if [ -z "$l_output2" ]; then echo -e "\n- Audit Result:\n *** PASS ***\n$l_output" else echo -e "\n- Audit Result:\n *** FAIL ***\n$l_output2\n\n - Correctly set:\n$l_output" fi ) }
echo "> "
echo "> 5.2.4 Ensure SSH access is limited (Automated)"
echo "> "
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -Pi '^\h*(allow|deny)(users|groups)\h+\H+(\h+.*)?$'
grep -Pi '^\h*(allow|deny)(users|groups)\h+\H+(\h+.*)?$' /etc/ssh/sshd_config
echo "> Verify that the output of both commands matches at least one of the following lines:"
echo "> allowusers <userlist>"
echo "> allowgroups <grouplist>"
echo "> denyusers <userlist>"
echo "> denygroups <grouplist>"
echo "> "
echo "> 5.2.5 Ensure SSH LogLevel is appropriate (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches loglevel VERBOSE or loglevel INFO:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep loglevel
echo "> loglevel VERBOSE or loglevel INFO"
echo "> Run the following command and verify the output matches:"
grep -i 'loglevel' /etc/ssh/sshd_config | grep -Evi '(VERBOSE|INFO)'
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.6 Ensure SSH PAM is enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -i usepam
echo "> usepam yes"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*UsePAM\s+no' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.7 Ensure SSH root login is disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep permitrootlogin
echo "> permitrootlogin no"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*PermitRootLogin\s+yes' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.8 Ensure SSH HostbasedAuthentication is disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep hostbasedauthentication
echo "> hostbasedauthentication no"
echo "> Run the following command and verify the output matches:"
grep -Ei '^\s*HostbasedAuthentication\s+yes' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.9 Ensure SSH PermitEmptyPasswords is disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep permitemptypasswords
echo "> permitemptypasswords no"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*PermitEmptyPasswords\s+yes' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.10 Ensure SSH PermitUserEnvironment is disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep permituserenvironment
echo "> permituserenvironment no"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*PermitUserEnvironment\s+yes' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.11 Ensure SSH IgnoreRhosts is enabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep ignorerhosts
echo "> ignorerhosts yes"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*ignorerhosts\s+no\b' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.12 Ensure SSH X11 forwarding is disabled (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -i x11forwarding
echo "> x11forwarding no"
echo "> Run the following command and verify that the output matches:"
grep -Ei '^\s*x11forwarding\s+yes' /etc/ssh/sshd_config
echo "> Nothing is returned"
echo "> "
echo "> 5.2.14 Ensure system-wide crypto policy is not over-ridden (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command:"
grep -i '^\s*CRYPTO_POLICY=' /etc/sysconfig/sshd
echo "> No output should be returned"
echo "> "
echo "> 5.2.15 Ensure SSH warning banner is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output matches:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep banner
echo "> banner /etc/issue.net"
echo "> "
echo "> 5.2.16 Ensure SSH MaxAuthTries is set to 4 or less (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output MaxAuthTries is 4 or less:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep maxauthtries
echo "> maxauthtries 4"
echo "> Run the following command and verify that the output:"
grep -Ei '^\s*maxauthtries\s+([5-9]|[1-9][0-9]+)' /etc/ssh/sshd_config
echo "> Nothing is returned"
echo "> "
echo "> 5.2.17 Ensure SSH MaxStartups is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output MaxStartups is 10:30:60 or more restrictive:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -i maxstartups
echo "> maxstartups 10:30:60"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*maxstartups\s+(((1[1-9]|[1-9][0-9][0-9]+):([0-9]+):([0-9]+))|(([0-9]+):(3[1-9]|[4-9][0-9]|[1-9][0-9][0-9]+):([0-9]+))|(([0-9]+):([0-9]+):(6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+)))' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.18 Ensure SSH MaxSessions is set to 10 or less (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output MaxSessions is 10 or less:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -i maxsessions
echo "> maxsessions 10"
echo "> Run the following command and verify the output:"
echo "> grep -Ei '^\s*MaxSessions\s+(1[1-9]|[2-9][0-9]|[1-9][0-9][0-9]+)' /etc/ssh/sshd_config"
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.19 Ensure SSH LoginGraceTime is set to one minute or less (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that output LoginGraceTime is between 1 and 60 seconds or 1m:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep logingracetime
echo "> logingracetime 60"
echo "> Run the following command and verify the output:"
grep -Ei '^\s*LoginGraceTime\s+(0|6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+|[^1]m)' /etc/ssh/sshd_config
echo "> Nothing should be returned"
echo "> "
echo "> 5.2.20 Ensure SSH Idle Timeout Interval is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands and verify ClientAliveInterval is greater than zero:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep clientaliveinterval
echo "> Example output:"
echo "> clientaliveinterval 15"
echo "> Run the following command and verify ClientAliveCountMax is greater than zero:"
sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep clientalivecountmax
echo "> Example output:"
echo "> clientalivecountmax 3"
echo "> "
echo "> 5.3.2 Ensure sudo commands use pty (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify that sudo can only run other commands from a pseudo terminal. Run the following command:"
grep -rPi '^\h*Defaults\h+([^#\n\r]+,)?use_pty(,\h*\h+\h*)*\h*(#.*)?$' /etc/sudoers*
echo "> /etc/sudoers:Defaults use_pty"
echo "> "
echo "> 5.3.3 Ensure sudo log file exists (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify that sudo has a custom log file configured"
grep -rPsi "^\h*Defaults\h+([^#]+,\h*)?logfile\h*=\h*(\"|\')?\H+(\"|\')?(,\h*\H+\h*)*\h*(#.*)?$" /etc/sudoers*
echo "> Defaults logfile="/var/log/sudo.log""
echo "> "
echo "> 5.3.5 Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify the operating system requires users to re-authenticate for privilege escalation. Check the configuration of the /etc/sudoers and /etc/sudoers.d/* files with the following command:"
grep -r "^[^#].*\!authenticate" /etc/sudoers*
echo "> If any line is found with a !authenticate tag, refer to the remediation procedure below."
echo "> "
echo "> 5.3.6 Ensure sudo authentication timeout is configured correctly (Automated)"
echo "> "
echo "> Audit:"
echo "> Ensure that the caching timeout is no more than 15 minutes. Example:"
grep -roP "timestamp_timeout=\K[0-9]*" /etc/sudoers*
echo "> If there is no timestamp_timeout configured in /etc/sudoers* then the default is 5 minutes. This default can be checked with:"
sudo -V | grep "Authentication timestamp timeout:"
echo "> NOTE: A value of -1 means that the timeout is disabled. Depending on the configuration of the timestamp_type, this could mean for all terminals / processes of that user and not just that one single terminal session."
echo "> "
echo "> 5.3.7 Ensure access to the su command is restricted (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify the output matches the line:"
grep -Pi '^\h*auth\h+(?:required|requisite)\h+pam_wheel\.so\h+(?:[^#\n\r]+\h+)?((?!\2)(use_uid\b|group=\H+\b))\h+(?:[^#\n\r]+\h+)?((?!\1)(use_uid\b|group=\H+\b))(\h+.*)?$' /etc/pam.d/su
echo "> auth required pam_wheel.so use_uid group=<group_name>"
echo "> Run the following command and verify that the group specified in <group_name> contains no users:"
grep <group_name> /etc/group
echo "> <group_name>:x:<GID>:"
echo "> There should be no users listed after the Group ID field."
echo "> "
echo "> 5.4.1 Ensure custom authselect profile is used (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following command to list the custom profile(s)"
authselect list | grep '^-\s*custom'
echo "> Verify output includes a custom profile"
echo "> "
echo "> 5.4.2 Ensure authselect includes with-faillock (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following commands to verify that faillock is enabled"
grep pam_faillock.so /etc/pam.d/password-auth /etc/pam.d/system-auth
echo "> Output should be similar to:"
echo "> /etc/authselect/password-auth:auth required"
echo "> pam_faillock.so preauth silent"
echo "> /etc/authselect/password-auth:auth required"
echo "> pam_faillock.so authfail"
echo "> /etc/authselect/password-auth:account required"
echo "> pam_faillock.so"
echo "> /etc/authselect/system-auth:auth required"
echo "> pam_faillock.so preauth silent"
echo "> /etc/authselect/system-auth:auth required"
echo "> pam_faillock.so authfail"
echo "> /etc/authselect/system-auth:account required"
echo "> pam_faillock.so"
echo "> "
echo "> 5.5.1 Ensure password creation requirements are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify password creation requirements conform to organization policy: Run the following command and verify that retry conforms to organization policy."
grep pam_pwquality.so /etc/pam.d/system-auth /etc/pam.d/password-auth
echo "> Output should be similar to:"
echo "> /etc/pam.d/system-auth:password requisite pam_pwquality.so try_first_pass local_users_only enforce_for_root retry=3"
echo "> /etc/pam.d/password-auth:password requisite pam_pwquality.so try_first_pass local_users_only enforce_for_root retry=3"
echo "> Run the following commands and verify password length requirements conform to organization policy."
grep ^minlen /etc/security/pwquality.conf
echo "> Verify minlen is 14 or more Run one of the following commands and verify that password complexity conforms to organization policy."
grep ^minclass /etc/security/pwquality.conf
echo "> "
echo "> 5.5.2 Ensure lockout for failed password attempts is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify password lockouts are configured. Depending on the version you are running, follow one of the two methods bellow."
echo "> • deny should not be 0 (never) or greater than 5"
echo "> • unlock_time should be 0 (never) or 900 seconds or more."
echo "> Run the following command to verify that Number of failed logon attempts before the account is locked is no greater than 5:"
grep -E '^\s*deny\s*=\s*[1-5]\b' /etc/security/faillock.conf
echo "> deny = 5"
echo "> Run the following command to verify that the time in seconds before the account is unlocked is either 0 (never) or 900 or more."
grep -E '^\s*unlock_time\s*=\s*(0|9[0-9][0-9]|[1-9][0-9][0-9][0-9]+)\b' /etc/security/faillock.conf
echo "> unlock_time = 900"
echo "> "
echo "> 5.5.3 Ensure password reuse is limited (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that the remembered password history is 5 or more"
grep -P '^\h*password\h+(requisite|sufficient)\h+(pam_pwhistory\.so|pam_unix\.so)\h+([^#\n\r]+\h+)?remember=([5-9]|[1-9][0-9]+)\h*(\h+.*)?$' /etc/pam.d/system-auth
echo "> The output should be similar to:"
echo "> password requisite pam_pwhistory.so try_first_pass local_users_only enforce_for_root retry=3 remember=5"
echo "> password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok remember=5"
echo "> "
echo "> 5.5.4 Ensure password hashing algorithm is SHA-512 or yescrypt (Automated)"
echo "> "
echo "> Audit:"
echo "> Verify password hashing algorithm is sha512 or yescrypt: Run the following command to verify the hashing algorithm is sha512 or yescrypt in /etc/libuser.conf:"
grep -Ei '^\s*crypt_style\s*=\s*(sha512|yescrypt)\b' /etc/libuser.conf
echo "> crypt_style = sha512"
echo "> Run the following command to verify the hashing algorithm is sha512 or yescrypt in /etc/login.defs:"
grep -Ei '^\s*ENCRYPT_METHOD\s+(SHA512|yescrypt)\b' /etc/login.defs
echo "> ENCRYPT_METHOD SHA512"
echo "> Run the following command to verify the hashing algorithm is configured with pam_unix.so in /etc/pam.d/system-auth and /etc/pam.d/password-auth:"
grep -P -- '^\h*password\h+(requisite|required|sufficient)\h+pam_unix\.so(\h+[^#\n\r]+)?\h+(sha512|yescrypt)\b.*$' /etc/pam.d/password-auth /etc/pam.d/system-auth
echo "> "
echo "> 5.6.1.1 Ensure password expiration is 365 days or less (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify PASS_MAX_DAYS conforms to site policy (no more than 365 days):"
grep PASS_MAX_DAYS /etc/login.defs
echo "> PASS_MAX_DAYS 365"
echo "> Run the following command and Review list of users and PASS_MAX_DAYS to verify that all users' PASS_MAX_DAYS conforms to site policy (no more than 365 days):"
grep -E '^[^:]+:[^!*]' /etc/shadow | cut -d: -f1,5
echo "> <user>:<PASS_MAX_DAYS>"
echo "> "
echo "> 5.6.1.2 Ensure minimum days between password changes is configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify PASS_MIN_DAYS conforms to site policy (no less than 1 day):"
grep PASS_MIN_DAYS /etc/login.defs
echo "> PASS_MIN_DAYS 1"
echo "> "
echo "> 5.6.1.3 Ensure password expiration warning days is 7 or more (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify PASS_WARN_AGE conforms to site policy (No less than 7 days):"
grep PASS_WARN_AGE /etc/login.defs
echo "> PASS_WARN_AGE 7"
echo "> "
echo "> 5.6.1.4 Ensure inactive password lock is 30 days or less (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify INACTIVE conforms to site policy (no more than 30 days):"
useradd -D | grep INACTIVE
echo "> INACTIVE=30"
echo "> "
echo "> 5.6.1.5 Ensure all users last password change date is in the past (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify nothing is returned"
awk -F: '/^[^:]+:[^!*]/{print $1}' /etc/shadow | while read -r usr; \ do change=$(date -d "$(chage --list $usr | grep '^Last password change' | cut -d: -f2 | grep -v 'never$')" +%s); \ if [[ "$change" -gt "$(date +%s)" ]]; then \ echo "User: \"$usr\" last password change was \"$(chage --list $usr | grep '^Last password change' | cut -d: -f2)\""; fi; done
echo "> "
echo "> 5.6.2 Ensure system accounts are secured (Automated)"
echo "> "
echo "> Audit:"
echo "> System accounts"
echo "> Check critical system accounts for nologin Run the following command:"
awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $7!~/^(\/usr)?\/sbin\/nologin$/) { print $1 }' /etc/passwd
echo "> Verify no results are returned."
echo "> "
echo "> 5.6.3 Ensure default user shell timeout is 900 seconds or less (Automated)"
echo "> "
/usr/bin/env bash { output1="" output2="" [ -f /etc/bashrc ] && BRC="/etc/bashrc" for f in "$BRC" /etc/profile /etc/profile.d/*.sh ; do grep -Pq '^\s*([^#]+\s+)?TMOUT=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9])\b' "$f" && grep -Pq '^\s*([^#]+;\s*)?readonly\s+TMOUT(\s+|\s*;|\s*$|=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9]))\b' "$f" && grep -Pq '^\s*([^#]+;\s*)?export\s+TMOUT(\s+|\s*;|\s*$|=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9]))\b' "$f" && output1="$f" done grep -Pq '^\s*([^#]+\s+)?TMOUT=(9[0-9][1-9]|9[1-9][0-9]|0+|[1-9]\d{3,})\b' /etc/profile /etc/profile.d/*.sh "$BRC" && output2=$(grep -Ps '^\s*([^#]+\s+)?TMOUT=(9[0-9][1-9]|9[1-9][0-9]|0+|[1-9]\d{3,})\b' /etc/profile /etc/profile.d/*.sh $BRC) if [ -n "$output1" ] && [ -z "$output2" ]; then echo -e "\nPASSED\n\nTMOUT is configured in: \"$output1\"\n" else [ -z "$output1" ] && echo -e "\nFAILED\n\nTMOUT is not configured\n" [ -n "$output2" ] && echo -e "\nFAILED\n\nTMOUT is incorrectly configured in: \"$output2\"\n" fi }
echo "> "
echo "> 5.6.4 Ensure default group for the root account is GID 0 (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify the result is 0 :"
grep "^root:" /etc/passwd | cut -f4 -d:
echo "> 0"
echo "> "
echo "> 5.6.5 Ensure default user umask is 027 or more restrictive (Automated)"
echo "> "
passing="" grep -Eiq '^\s*UMASK\s+(0[0-7][2-7]7|[0-7][2-7]7)\b' /etc/login.defs && grep -Eqi '^\s*USERGROUPS_ENAB\s*"?no"?\b' /etc/login.defs && grep -Eq '^\s*session\s+(optional|requisite|required)\s+pam_umask\.so\b' /etc/pam.d/common-session && passing=true grep -REiq '^\s*UMASK\s+\s*(0[0-7][2-7]7|[0-7][2-7]7|u=(r?|w?|x?)(r?|w?|x?)(r?|w?|x?),g=(r?x?|x?r?),o=)\b' /etc/profile* /etc/bashrc* && passing=true [ "$passing" = true ] && echo "Default user umask is set"
echo "> "
echo "> Verify output is: "Default user umask is set" Run the following to verify that no less restrictive system wide umask is set:"
grep -RPi '(^|^[^#]*)\s*umask\s+([0-7][0-7][01][0-7]\b|[0-7][0-7][0-7][0-6]\b|[0-7][01][0-7]\b|[0-7][0-7][0-6]\b|(u=[rwx]{0,3},)?(g=[rwx]{0,3},)?o=[rwx]+\b|(u=[rwx]{1,3},)?g=[^rx]{1,3}(,o=[rwx]{0,3})?\b)' /etc/login.defs /etc/profile* /etc/bashrc*
echo "> No file should be returned"
echo "> "
echo "> 5.6.6 Ensure root password is set (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command:"
passwd -S root
echo "> Verify that the output contains "Password set"."
echo "> "
echo "> 6.1.1 Ensure permissions on /etc/passwd are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/passwd is mode 644 or more restrictive, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/passwd
echo "> /etc/passwd 644 0/root 0/root"
echo "> "
echo "> 6.1.2 Ensure permissions on /etc/passwd- are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/passwd- is mode 644 or more restrictive, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/passwd-
echo "> /etc/passwd- 644 0/root 0/root"
echo "> "
echo "> 6.1.3 Ensure permissions on /etc/group are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/group is mode 644 or more restrictive, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/group
echo "> /etc/group 644 0/root 0/root"
echo "> "
echo "> 6.1.4 Ensure permissions on /etc/group- are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/group- is mode 644 or more restrictive, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/group-
echo "> /etc/group- 644 0/root 0/root"
echo "> "
echo "> 6.1.5 Ensure permissions on /etc/shadow are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/shadow is mode 000, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/shadow
echo "> /etc/shadow 0 0/root 0/root"
echo "> "
echo "> 6.1.6 Ensure permissions on /etc/shadow- are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/shadow- is mode 000, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/shadow-
echo "> /etc/shadow- 0 0/root 0/root"
echo "> "
echo "> 6.1.7 Ensure permissions on /etc/gshadow are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/gshadow is mode 000, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/gshadow
echo "> /etc/gshadow 0 0/root 0/root"
echo "> "
echo "> 6.1.8 Ensure permissions on /etc/gshadow- are configured (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify /etc/gshadow- is mode 000, Uid is 0/root and Gid is 0/root:"
stat -Lc "%n %a %u/%U %g/%G" /etc/gshadow-
echo "> /etc/gshadow- 0 0/root 0/root"
echo "> "
echo "> 6.1.9 Ensure no world writable files exist (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify no files are returned:"
df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type f -perm -0002
echo "> "
echo "> 6.1.10 Ensure no unowned files or directories exist (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify no files are returned:"
df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -nouser
echo "> "
echo "> 6.1.11 Ensure no ungrouped files or directories exist (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify no files are returned:"
df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -nogroup
echo "> "
echo "> 6.1.12 Ensure sticky bit is set on all world-writable directories (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command to verify no world writable directories exist without the sticky bit set:"
df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null
echo "> "
echo "> 6.1.13 Audit SUID executables (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following command to list SUID files:"
df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type f -perm -4000
echo "> "
echo "> 6.1.14 Audit SGID executables (Manual)"
echo "> "
echo "> Audit:"
echo "> Run the following command to list SGID files:"
df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type f -perm -2000
echo "> "
echo "> 6.2.1 Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that no output is returned:"
awk -F: '($2 != "x" ) { print $1 " is not set to shadowed passwords "}' /etc/passwd
echo "> "
echo "> 6.2.2 Ensure /etc/shadow password fields are not empty (Automated)"
echo "> "
echo "> Audit:"
echo "> Run the following command and verify that no output is returned:"
awk -F: '($2 == "" ) { print $1 " does not have a password "}' /etc/shadow
echo "> "
echo "> 6.2.3 Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
echo "> "
for i in $(cut -s -d: -f4 /etc/passwd | sort -u ); do grep -q -P "^.*?:[^:]*:$i:" /etc/group if [ $? -ne 0 ]; then echo "Group $i is referenced by /etc/passwd but does not exist in /etc/group" fi done
echo "> "
echo "> 6.2.4 Ensure no duplicate UIDs exist (Automated)"
echo "> "
cut -f3 -d":" /etc/passwd | sort -n | uniq -c | while read x ; do [ -z "$x" ] && break set - $x if [ $1 -gt 1 ]; then users=$(awk -F: '($3 == n) { print $1 }' n=$2 /etc/passwd | xargs) echo "Duplicate UID ($2): $users" fi done
echo "> "
echo "> 6.2.5 Ensure no duplicate GIDs exist (Automated)"
echo "> "
cut -d: -f3 /etc/group | sort | uniq -d | while read x ; do echo "Duplicate GID ($x) in /etc/group" done
echo "> "
echo "> 6.2.6 Ensure no duplicate user names exist (Automated)"
echo "> "
cut -d: -f1 /etc/passwd | sort | uniq -d | while read -r x; do echo "Duplicate login name $x in /etc/passwd" done
echo "> "
echo "> 6.2.7 Ensure no duplicate group names exist (Automated)"
echo "> "
cut -d: -f1 /etc/group | sort | uniq -d | while read -r x; do echo "Duplicate group name $x in /etc/group" done
echo "> "
echo "> 6.2.8 Ensure root PATH Integrity (Automated)"
echo "> "
RPCV="$(sudo -Hiu root env | grep '^PATH' | cut -d= -f2)" echo "$RPCV" | grep -q "::" && echo "root's path contains a empty directory (::)" echo "$RPCV" | grep -q ":$" && echo "root's path contains a trailing (:)" for x in $(echo "$RPCV" | tr ":" " "); do if [ -d "$x" ]; then ls -ldH "$x" | awk '$9 == "." {print "PATH contains current working directory (.)"} $3 != "root" {print $9, "is not owned by root"} substr($1,6,1) != "-" {print $9, "is group writable"} substr($1,9,1) != "-" {print $9, "is world writable"}' else echo "$x is not a directory" fi done
echo "> "
echo "> 6.2.9 Ensure root is the only UID 0 account (Automated)"
echo "> "
awk -F: '($3 == 0) { print $1 }' /etc/passwd
echo "> root"
echo "> "
echo "> 6.2.10 Ensure local interactive user home directories exist (Automated)"
echo "> "
/usr/bin/env bash { output="" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do [ ! -d "$home" ] && output="$output\n - User \"$user\" home directory \"$home\" doesn't exist" done if [ -z "$output" ]; then echo -e "\n-PASSED: - All local interactive users have a home directory\n" else echo -e "\n- FAILED:\n$output\n" fi ) }
echo "> "
echo "> 6.2.11 Ensure local interactive users own their home directories (Automated)"
echo "> "
/usr/bin/env bash { output="" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do owner="$(stat -L -c "%U" "$home")" [ "$owner" != "$user" ] && output="$output\n - User \"$user\" home directory \"$home\" is owned by user \"$owner\"" done if [ -z "$output" ]; then echo -e "\n-PASSED: - All local interactive users have a home directory\n" else echo -e "\n- FAILED:\n$output\n" fi ) }
echo "> "
echo "> 6.2.12 Ensure local interactive user home directories are mode 750 or more restrictive (Automated)"
echo "> "
/usr/bin/env bash { output="" perm_mask='0027' maxperm="$( printf '%o' $(( 0777 & ~$perm_mask)) )" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do mode=$( stat -L -c '%#a' "$home" ) [ $(( $mode & $perm_mask )) -gt 0 ] && output="$output\n- User $user home directory: \"$home\" is too permissive: \"$mode\" (should be: \"$maxperm\" or more restrictive)" done if [ -n "$output" ]; then echo -e "\n- Failed:$output" else echo -e "\n- Passed:\n- All user home directories are mode: \"$maxperm\" or more restrictive" fi ) }
echo "> "
echo "> 6.2.13 Ensure no local interactive user has .netrc files (Automated)"
echo "> "
/usr/bin/env bash { output="" output2="" perm_mask='0177' maxperm="$( printf '%o' $(( 0777 & ~$perm_mask)) )" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do if [ -f "$home/.netrc" ]; then mode="$( stat -L -c '%#a' "$home/.netrc" )" if [ $(( $mode & $perm_mask )) -gt 0 ]; then output="$output\n - User \"$user\" file: \"$home/.netrc\" is too permissive: \"$mode\" (should be: \"$maxperm\" or more restrictive)" else output2="$output2\n - User \"$user\" file: \"$home/.netrc\" exists and has file mode: \"$mode\" (should be: \"$maxperm\" or more restrictive)" fi fi done if [ -z "$output" ]; then if [ -z "$output2" ]; then echo -e "\n-PASSED: - No local interactive users have \".netrc\" files in their home directory\n" else echo -e "\n- WARNING:\n$output2\n" fi else echo -e "\n- FAILED:\n$output\n" [ -n "$output2" ] && echo -e "\n- WARNING:\n$output2\n" fi ) }
echo "> "
echo "> 6.2.14 Ensure no local interactive user has .forward files (Automated)"
echo "> "
/usr/bin/env bash { output="" fname=".forward" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do [ -f "$home/$fname" ] && output="$output\n - User \"$user\" file: \"$home/$fname\" exists" done if [ -z "$output" ]; then echo -e "\n-PASSED: - No local interactive users have \"$fname\" files in their home directory\n" else echo -e "\n- FAILED:\n$output\n" fi ) }
echo "> "
echo "> 6.2.15 Ensure no local interactive user has .rhosts files (Automated)"
echo "> "
/usr/bin/env bash { output="" fname=".rhosts" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do [ -f "$home/$fname" ] && output="$output\n - User \"$user\" file: \"$home/$fname\" exists" done if [ -z "$output" ]; then echo -e "\n-PASSED: - No local interactive users have \"$fname\" files in their home directory\n" else echo -e "\n- FAILED:\n$output\n" fi ) }
echo "> "
echo "> 6.2.16 Ensure local interactive user dot files are not group or world writable (Automated)"
echo "> "
/usr/bin/env bash { output="" perm_mask='0022' maxperm="$( printf '%o' $(( 0777 & ~$perm_mask)) )" valid_shells="^($( sed -rn '/^\//{s,/,\\\\/,g;p}' /etc/shells | paste -s -d '|' - ))$" awk -v pat="$valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd | (while read -r user home; do for dfile in $(find "$home" -type f -name '.*'); do mode=$( stat -L -c '%#a' "$dfile" ) [ $(( $mode & $perm_mask )) -gt 0 ] && output="$output\n- User $user file: \"$dfile\" is too permissive: \"$mode\" (should be: \"$maxperm\" or more restrictive)" done done if [ -n "$output" ]; then echo -e "\n- Failed:$output" else echo -e "\n- Passed:\n- All user home dot files are mode: \"$maxperm\" or more restrictive" fi ) }
